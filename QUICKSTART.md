# 🚀 Quick Start Guide

Get your Leptos app running in 5 minutes!

## What You Have

You have a complete Leptos project with:
- **src/lib.rs** - Rust code defining your interactive UI
- **public/index.html** - HTML entry point with styling
- **pkg/** - Compiled WebAssembly files (generated)

## Running Your App

### Step 1: Start the Web Server

The server should already be running. If not:

```bash
cd webtest/public
python3 -m http.server 8000
```

### Step 2: Open in Browser

Visit: **http://localhost:8000**

You should see a purple gradient with a white card containing a counter!

## Making Changes

### 1. Edit `src/lib.rs`

Open the file and modify the Rust code. For example, change:

```rust
let (count, set_count) = signal(0);
```

to:

```rust
let (count, set_count) = signal(100);
```

### 2. Rebuild WebAssembly

```bash
wasm-pack build --target web --release
```

Takes about 10-30 seconds.

### 3. Refresh Browser

Press `F5` (or `Ctrl+R`) to see your changes!

## Understanding the Code

### Signals = Reactive State

```rust
let (count, set_count) = signal(0);
```

- `count` - read the value
- `set_count` - update the value
- When it changes, the UI automatically updates!

### Event Handlers = Closures

```rust
let increment = move |_| set_count.update(|c| *c += 1);
```

- `move` - captures variables
- `|_|` - ignores the event parameter
- Updates the signal when called

### View = HTML in Rust

```rust
view! {
    <button on:click=increment>"+1"</button>
}
```

- Regular HTML elements
- `{count}` - inserts Rust values
- `on:click=handler` - event listeners

## Your First Challenge

**Make the counter start at 50:**

1. Open `src/lib.rs`
2. Find: `signal(0)`
3. Change to: `signal(50)`
4. Run: `wasm-pack build --target web --release`
5. Refresh browser
6. Done! ✅

## Common Patterns

### Update a Signal

```rust
// Replace value
set_count.set(0);

// Transform value (preferred)
set_count.update(|c| *c += 1);
```

### Show a Value

```rust
view! {
    <p>"Count: " {count}</p>
}
```

### Handle Click

```rust
let on_click = move |_| {
    // Do something
};

view! {
    <button on:click=on_click>"Click"</button>
}
```

### Conditional Rendering

```rust
view! {
    <p>
      {move || {
        if count.get() > 5 { "High" } else { "Low" }
      }}
    </p>
}
```

## Next Challenges

### Challenge 2: Add a Button
Add a "×2" button that multiplies the count:

```rust
let double = move |_| set_count.update(|c| *c *= 2);

// Add to view:
<button on:click=double>"×2"</button>
```

### Challenge 3: Style It
Modify the CSS in `public/index.html` to change colors, fonts, sizes.

### Challenge 4: Add Input
Let users type in a value:

```rust
let (input, set_input) = signal(String::new());

view! {
    <input
        type="text"
        prop:value=input
        on:input=move |ev| {
            use leptos::ev::*;
            set_input.set(event_target_value(&ev));
        }
    />
    <p>"You typed: " {input}</p>
}
```

## Debugging

### App not loading?
1. Check browser console: `F12`
2. Look for error messages
3. Make sure `pkg/` directory exists
4. Verify paths in `index.html`

### Changes not showing?
1. Did you run `wasm-pack build --target web --release`?
2. Did you refresh the browser?
3. Try `Ctrl+Shift+R` for hard refresh

### Compilation error?
Read the error message carefully. Rust's compiler is very helpful!

## Rebuild Workflow

Every time you change `src/lib.rs`:

```bash
# 1. Rebuild
wasm-pack build --target web --release

# 2. Refresh browser (F5)

# 3. See your changes!
```

## File Structure

```
webtest/
├── src/lib.rs              ← Your Rust code here
├── public/index.html       ← HTML + CSS styling
├── pkg/                    ← Generated by wasm-pack
│   ├── webtest.js         (auto-generated)
│   └── webtest_bg.wasm    (compiled from Rust)
├── Cargo.toml             ← Dependencies
└── README.md              ← Full documentation
```

## Key Concepts in 30 Seconds

1. **Signal** - A reactive value that updates the UI when it changes
2. **Component** - A function that returns a view (with `#[component]` macro)
3. **View** - HTML written in Rust using the `view!` macro
4. **Event Handler** - A closure that runs when something happens
5. **Reactive** - When a signal changes, only affected UI updates automatically

## Resources

- **README.md** - Detailed guide with concepts and more challenges
- **Leptos Book**: https://book.leptos.dev/
- **API Docs**: https://docs.rs/leptos/
- **Browser Console**: `F12` for errors and logs

## Ready to Level Up?

Check `README.md` for:
- 5 challenging exercises
- Advanced patterns
- Full API reference
- Learning resources

---

**You're all set!** Start with Challenge 1 (change starting value) and work your way up. Have fun! 🦀